import path from 'node:path';
import fse from 'fs-extra';
import chalk from 'chalk';
import type { GameDesignSnapshot, Genre, ColorPalette } from './snapshot.js';
import { getRunnerConfig } from './templates/runner.js';
import { getArenaConfig } from './templates/arena.js';
import { getPuzzleConfig } from './templates/puzzle.js';
import { generateConfigWithAI } from './ai.js';
import { generateAssets } from './assets.js';

function slugify(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');
}

function getTemplateConfig(snapshot: GameDesignSnapshot): string {
  switch (snapshot.genre) {
    case 'runner':
      return getRunnerConfig(snapshot);
    case 'arena':
      return getArenaConfig(snapshot);
    case 'puzzle':
      return getPuzzleConfig(snapshot);
  }
}

function generateReadme(snapshot: GameDesignSnapshot, templateReadme: string): string {
  return templateReadme
    .replace(/\{\{title\}\}/g, snapshot.title)
    .replace(/\{\{elevatorPitch\}\}/g, snapshot.elevatorPitch);
}

export async function generateGame(
  snapshot: GameDesignSnapshot,
  outputDir?: string,
  skipAssets: boolean = false,
): Promise<string> {
  const slug = slugify(snapshot.title);
  const targetDir = outputDir ?? path.resolve(process.cwd(), slug);

  console.log(chalk.blue('\nüìÅ Generating your game...'));

  // Create output directory
  await fse.ensureDir(targetDir);

  // Determine template source directory
  const templatesRoot = path.resolve(
    new URL(import.meta.url).pathname,
    '..', '..', '..', 'templates',
  );
  const templateDir = path.join(templatesRoot, snapshot.genre);

  // Check template exists
  if (!await fse.pathExists(templateDir)) {
    throw new Error(`Template not found: ${templateDir}`);
  }

  // Generate assets if not skipped
  if (!skipAssets) {
    await generateAssets(snapshot, targetDir);
  } else {
    console.log(chalk.dim('   ‚è≠ Skipping asset generation (--no-assets)'));
  }

  // Copy template files (excluding .tmpl files and config.js)
  const files = await fse.readdir(templateDir, { recursive: true }) as string[];

  for (const file of files) {
    const srcPath = path.join(templateDir, file);
    const stat = await fse.stat(srcPath);

    if (stat.isDirectory()) continue;
    if (file.endsWith('.tmpl')) continue;
    if (file === path.join('src', 'config.js') || file === 'src/config.js') continue;

    const destPath = path.join(targetDir, file);
    await fse.ensureDir(path.dirname(destPath));
    await fse.copy(srcPath, destPath);
    console.log(chalk.green(`   ‚úì Created ${slug}/${file}`));
  }

  // Generate config.js from snapshot (AI or Static)
  let configContent = await generateConfigWithAI(snapshot);
  if (!configContent) {
    configContent = getTemplateConfig(snapshot);
  } else {
    console.log(chalk.magenta('   ‚ú® Config generated by AI'));
  }

  const configPath = path.join(targetDir, 'src', 'config.js');
  await fse.ensureDir(path.dirname(configPath));
  await fse.writeFile(configPath, configContent, 'utf-8');
  console.log(chalk.green(`   ‚úì Created ${slug}/src/config.js`));

  // Generate README from template
  const readmeTmplPath = path.join(templateDir, 'README.md.tmpl');
  if (await fse.pathExists(readmeTmplPath)) {
    const tmpl = await fse.readFile(readmeTmplPath, 'utf-8');
    const readme = generateReadme(snapshot, tmpl);
    await fse.writeFile(path.join(targetDir, 'README.md'), readme, 'utf-8');
    console.log(chalk.green(`   ‚úì Created ${slug}/README.md`));
  }

  // Save game-snapshot.json for re-import and playtest
  await fse.writeJSON(path.join(targetDir, 'game-snapshot.json'), snapshot, { spaces: 2 });
  console.log(chalk.green(`   ‚úì Created ${slug}/game-snapshot.json`));

  return targetDir;
}
